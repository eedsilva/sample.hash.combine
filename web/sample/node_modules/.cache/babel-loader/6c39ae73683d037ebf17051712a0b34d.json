{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\"),\n    _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\")),\n    _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\")),\n    _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\")),\n    _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\")),\n    _PluginRepository = _interopRequireDefault(require(\"./plugins/PluginRepository\")),\n    _SocketService = _interopRequireDefault(require(\"./services/SocketService\")),\n    _Plugin = _interopRequireDefault(require(\"./plugins/Plugin\")),\n    PluginTypes = _interopRequireWildcard(require(\"./plugins/PluginTypes\"));\n\nvar origin,\n    _Blockchains = require(\"./models/Blockchains\"),\n    _Network = _interopRequireDefault(require(\"./models/Network\")),\n    throwNoAuth = function throwNoAuth() {\n  if (!holder.scatter.isExtension && !_SocketService.default.isConnected()) throw new Error(\"Connect and Authenticate first - scatter.connect( pluginName )\");\n},\n    checkForExtension = function checkForExtension(a) {\n  var b = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : 0;\n  return 20 < b ? void 0 : holder.scatter.isExtension ? a(!0) : void setTimeout(function () {\n    return checkForExtension(a, b + 1);\n  }, 100);\n},\n    Index =\n/*#__PURE__*/\nfunction () {\n  function a() {\n    (0, _classCallCheck2.default)(this, a), this.isExtension = !1, this.identity = null;\n  }\n\n  return (0, _createClass2.default)(a, [{\n    key: \"loadPlugin\",\n    value: function loadPlugin(a) {\n      var b = this;\n      if (!a.isValid()) throw new Error(\"\".concat(a.name, \" doesn't seem to be a valid ScatterJS plugin.\"));\n      _PluginRepository.default.loadPlugin(a), a.isSignatureProvider() && (this[a.name] = a.signatureProvider(function noIdFunc() {\n        if (!b.identity) throw new Error(\"No Identity\");\n      }, function () {\n        return b.identity;\n      }), this[a.name + \"Hook\"] = a.hookProvider);\n    }\n  }, {\n    key: \"connect\",\n    value: function () {\n      var a = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function a(b, c) {\n        var d = this;\n        return _regenerator.default.wrap(function (a) {\n          for (;;) {\n            switch (a.prev = a.next) {\n              case 0:\n                return a.abrupt(\"return\", new Promise(function (a) {\n                  if (!b || !b.length) throw new Error(\"You must specify a name for this connection\"); // Setting options defaults\n\n                  c = Object.assign({\n                    initTimeout: 1e4,\n                    linkTimeout: 3e4\n                  }, c), setTimeout(function () {\n                    a(!1);\n                  }, c.initTimeout), checkForExtension(a), _SocketService.default.init(b, c.linkTimeout), _SocketService.default.link().then(\n                  /*#__PURE__*/\n                  function () {\n                    var b = (0, _asyncToGenerator2.default)(\n                    /*#__PURE__*/\n                    _regenerator.default.mark(function b(c) {\n                      return _regenerator.default.wrap(function (b) {\n                        for (;;) {\n                          switch (b.prev = b.next) {\n                            case 0:\n                              if (c) {\n                                b.next = 2;\n                                break;\n                              }\n\n                              return b.abrupt(\"return\", !1);\n\n                            case 2:\n                              return b.next = 4, d.getIdentityFromPermissions();\n\n                            case 4:\n                              return d.identity = b.sent, b.abrupt(\"return\", a(!0));\n\n                            case 6:\n                            case \"end\":\n                              return b.stop();\n                          }\n                        }\n                      }, b, this);\n                    }));\n                    return function () {\n                      return b.apply(this, arguments);\n                    };\n                  }());\n                }));\n\n              case 1:\n              case \"end\":\n                return a.stop();\n            }\n          }\n        }, a, this);\n      }));\n      return function connect() {\n        return a.apply(this, arguments);\n      };\n    }()\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      return _SocketService.default.disconnect();\n    }\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      return _SocketService.default.isConnected();\n    }\n  }, {\n    key: \"isPaired\",\n    value: function isPaired() {\n      return _SocketService.default.isPaired();\n    }\n  }, {\n    key: \"getVersion\",\n    value: function getVersion() {\n      return _SocketService.default.sendApiRequest({\n        type: \"getVersion\",\n        payload: {}\n      });\n    }\n    /***\r\n    * Logs a user into your application\r\n    * @param requiredFields\r\n    * @returns {Promise<any>}\r\n    */\n\n  }, {\n    key: \"login\",\n    value: function login(a) {\n      var b = this;\n      return throwNoAuth(), _SocketService.default.sendApiRequest({\n        type: \"getOrRequestIdentity\",\n        payload: {\n          fields: a\n        }\n      }).then(function (a) {\n        return a && (b.identity = a), a;\n      });\n    }\n    /***\r\n    * Check is a user is logged in by tapping\r\n    * their Scatter, but does not issue a popup\r\n    * @returns {Promise<any>}\r\n    */\n\n  }, {\n    key: \"checkLogin\",\n    value: function checkLogin() {\n      var a = this;\n      return throwNoAuth(), _SocketService.default.sendApiRequest({\n        type: \"identityFromPermissions\",\n        payload: {}\n      }).then(function (b) {\n        return b && (a.identity = b), b;\n      });\n    }\n    /***\r\n    * Logs a user out of your application.\r\n    * @returns {Promise<any>}\r\n    */\n\n  }, {\n    key: \"logout\",\n    value: function logout() {\n      var a = this;\n      return throwNoAuth(), _SocketService.default.sendApiRequest({\n        type: \"forgetIdentity\",\n        payload: {}\n      }).then(function (b) {\n        return a.identity = null, b;\n      });\n    }\n    /***\r\n    * Authenticates a user's login using\r\n    * asymmetric encryption.\r\n    * @param nonce\r\n    */\n\n  }, {\n    key: \"authenticate\",\n    value: function authenticate(a) {\n      return throwNoAuth(), _SocketService.default.sendApiRequest({\n        type: \"authenticate\",\n        payload: {\n          nonce: a\n        }\n      });\n    }\n  }, {\n    key: \"getArbitrarySignature\",\n    value: function getArbitrarySignature(a, b) {\n      return throwNoAuth(), _SocketService.default.sendApiRequest({\n        type: \"requestArbitrarySignature\",\n        payload: {\n          publicKey: a,\n          data: b\n        }\n      });\n    }\n  }, {\n    key: \"getPublicKey\",\n    value: function getPublicKey(a) {\n      return throwNoAuth(), _SocketService.default.sendApiRequest({\n        type: \"getPublicKey\",\n        payload: {\n          blockchain: a\n        }\n      });\n    }\n  }, {\n    key: \"linkAccount\",\n    value: function linkAccount(a, b) {\n      return throwNoAuth(), _SocketService.default.sendApiRequest({\n        type: \"linkAccount\",\n        payload: {\n          account: a,\n          network: b\n        }\n      });\n    }\n  }, {\n    key: \"hasAccountFor\",\n    value: function hasAccountFor(a) {\n      return throwNoAuth(), _SocketService.default.sendApiRequest({\n        type: \"hasAccountFor\",\n        payload: {\n          network: a\n        }\n      });\n    }\n  }, {\n    key: \"suggestNetwork\",\n    value: function suggestNetwork(a) {\n      return throwNoAuth(), _SocketService.default.sendApiRequest({\n        type: \"requestAddNetwork\",\n        payload: {\n          network: a\n        }\n      });\n    }\n  }, {\n    key: \"requestTransfer\",\n    value: function requestTransfer(a, b, c) {\n      var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : {};\n      return _SocketService.default.sendApiRequest({\n        type: \"requestTransfer\",\n        payload: {\n          network: a,\n          to: b,\n          amount: c,\n          options: d\n        }\n      });\n    }\n  }, {\n    key: \"requestSignature\",\n    value: function requestSignature(a) {\n      return throwNoAuth(), _SocketService.default.sendApiRequest({\n        type: \"requestSignature\",\n        payload: a\n      });\n    }\n  }, {\n    key: \"createTransaction\",\n    value: function createTransaction(a, b, c, d) {\n      return throwNoAuth(), _SocketService.default.sendApiRequest({\n        type: \"createTransaction\",\n        payload: {\n          blockchain: a,\n          actions: b,\n          account: c,\n          network: d\n        }\n      });\n    }\n    /******************************/\n\n    /******** DEPRECATED **********/\n\n    /******************************/\n    // @deprecated - Use `login(requiredFields)`\n\n  }, {\n    key: \"getIdentity\",\n    value: function getIdentity(a) {\n      return this.login(a);\n    } // @deprecated - Use `checkLogin()`\n\n  }, {\n    key: \"getIdentityFromPermissions\",\n    value: function getIdentityFromPermissions() {\n      return this.checkLogin();\n    } // @deprecated - Use `logout()`\n\n  }, {\n    key: \"forgetIdentity\",\n    value: function forgetIdentity() {\n      return this.logout();\n    }\n  }]), a;\n}(),\n    Holder =\n/*#__PURE__*/\nfunction () {\n  function a(b) {\n    (0, _classCallCheck2.default)(this, a), this.scatter = b;\n  }\n\n  return (0, _createClass2.default)(a, [{\n    key: \"plugins\",\n    value: function plugins() {\n      var a = this;\n\n      if (!this.scatter.isExtension) {\n        for (var b = arguments.length, c = Array(b), d = 0; d < b; d++) {\n          c[d] = arguments[d];\n        }\n\n        c.map(function (b) {\n          return a.scatter.loadPlugin(b);\n        });\n      }\n    }\n  }]), a;\n}(),\n    holder = new Holder(new Index());\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n}), Object.defineProperty(exports, \"SocketService\", {\n  enumerable: !0,\n  get: function get() {\n    return _SocketService.default;\n  }\n}), Object.defineProperty(exports, \"Plugin\", {\n  enumerable: !0,\n  get: function get() {\n    return _Plugin.default;\n  }\n}), Object.defineProperty(exports, \"Blockchains\", {\n  enumerable: !0,\n  get: function get() {\n    return _Blockchains.Blockchains;\n  }\n}), Object.defineProperty(exports, \"Network\", {\n  enumerable: !0,\n  get: function get() {\n    return _Network.default;\n  }\n}), exports.PluginTypes = exports.default = void 0;\nexports.PluginTypes = PluginTypes;\n\nif (\"undefined\" != typeof window) {\n  // Catching extension instead of Desktop\n  if (\"undefined\" != typeof document) {\n    var bindScatterClassic = function bindScatterClassic() {\n      holder.scatter = window.scatter, holder.scatter.isExtension = !0, holder.scatter.connect = function () {\n        return new Promise(function (a) {\n          return a(!0);\n        });\n      };\n    };\n\n    \"undefined\" == typeof window.scatter ? document.addEventListener(\"scatterLoaded\", function () {\n      return bindScatterClassic();\n    }) : bindScatterClassic();\n  }\n\n  window.ScatterJS = holder;\n}\n\nholder.Plugin = _Plugin.default, holder.PluginTypes = PluginTypes, holder.Blockchains = _Blockchains.Blockchains, holder.Network = _Network.default, holder.SocketService = _SocketService.default;\nvar _default = holder;\nexports.default = _default;","map":null,"metadata":{},"sourceType":"script"}